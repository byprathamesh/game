<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Night Driver</title>
  <meta name="description" content="Night Driver: A neon endless racer game. Dodge obstacles, rack up your score, and enjoy retro visuals!">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #101020 60%, #000 100%);
      min-height: 100vh;
      font-family: 'Segoe UI', Arial, sans-serif;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #gameContainer {
      position: relative;
      width: 360px;
      height: 640px;
      max-width: 100vw;
      max-height: 100vh;
      box-shadow: 0 0 32px #0ff8, 0 0 8px #00f4, 0 0 0 #000;
      border-radius: 18px;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 1.3rem;
      letter-spacing: 1px;
      z-index: 2;
      user-select: none;
      text-shadow: 0 0 4px #0ff, 0 0 8px #00f, 0 0 2px #fff;
    }
    #gameOverScreen {
      display: none;
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(10,10,40,0.92);
      color: #fff;
      z-index: 10;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      text-shadow: 0 0 8px #0ff, 0 0 2px #fff;
    }
    #gameOverScreen button {
      margin-top: 24px;
      padding: 12px 32px;
      font-size: 1.2rem;
      border-radius: 8px;
      border: none;
      background: linear-gradient(90deg,#0ff,#08f 80%);
      color: #111;
      font-weight: bold;
      box-shadow: 0 0 8px #0ff;
      cursor: pointer;
    }
    #mobileControls {
      position: absolute;
      bottom: 18px;
      left: 0;
      width: 100%;
      display: flex;
      flex-direction: row;
      justify-content: center;
      gap: 32px;
      z-index: 3;
      pointer-events: none;
    }
    .ctrl-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(0,255,255,0.12);
      border: 2px solid #0ff;
      color: #0ff;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px #0ff8;
      pointer-events: auto;
      user-select: none;
      touch-action: none;
      transition: background 0.2s;
    }
    .ctrl-btn:active {
      background: rgba(0,255,255,0.32);
    }
    @media (max-width: 500px) {
      #gameContainer { width: 98vw; height: 70vw; min-height: 320px; }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="360" height="640"></canvas>
    <div id="hud">
      <span id="score">0</span> m
      <span style="margin-left:16px; font-size:0.9em;">Best: <span id="bestScore">0</span></span>
    </div>
    <div id="gameOverScreen">
      <div style="margin-top: 120px;">Game Over<br><span id="finalScore">0</span> m</div>
      <button id="restartBtn">Restart</button>
    </div>
    <div id="mobileControls">
      <button class="ctrl-btn" id="leftBtn">⟵</button>
      <button class="ctrl-btn" id="rightBtn">⟶</button>
    </div>
  </div>
  <script>
    // --- Game Constants ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    let roadScroll = 0;

    // --- Starfield ---
    const stars = Array.from({length: 50}, () => ({
      x: Math.random()*w,
      y: Math.random()*h,
      speed: 0.2 + Math.random()*0.5
    }));
    function drawStars(dt) {
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = '#fff';
      for (let s of stars) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, 1.1+Math.random()*1.2, 0, 2*Math.PI);
        ctx.fill();
        s.y += s.speed * player.speed * dt * 1.2;
        if (s.y > h) s.y = 0, s.x = Math.random()*w;
      }
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }

    // --- Headlight effect ---
    function drawHeadlights() {
      ctx.save();
      ctx.globalAlpha = 0.22;
      const grad = ctx.createRadialGradient(player.x, player.y-20, 16, player.x, player.y-120, 160);
      grad.addColorStop(0, '#fff8');
      grad.addColorStop(0.1, '#0ff6');
      grad.addColorStop(0.4, '#0ff2');
      grad.addColorStop(1, 'transparent');
      ctx.beginPath();
      ctx.ellipse(player.x, player.y-60, 70, 170, 0, 0, 2*Math.PI);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }

    // --- Near-miss shake ---
    let shake = 0, shakeTimer = 0;
    function triggerShake(intensity=1) {
  shake = 18 * intensity;
  shakeTimer = 0.22 * intensity;
}
    function applyShake(dt) {
      if (shake > 0) {
        shakeTimer -= dt;
        if (shakeTimer < 0) shake = 0;
      }
    }

    // --- Game State ---
    let player = { x: w/2, y: h/2, width: 38, height: 64, speed: 15, color: '#0ff' }; // Car in center, even faster
    let obstacles = [], obstacleTimer = 0, obstacleInterval = 540, minInterval = 120; // even faster spawn, higher min speed
    let distance = 0, score = 0, bestScore = 0;
    let gameOver = false;
    let leftPressed = false, rightPressed = false;
    // --- Controls ---
    function resetControls() { leftPressed = rightPressed = false; }
    document.addEventListener('keydown', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = true;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = true;
      if (gameOver && (e.key===' '||e.key==='Enter')) restartGame();
    });
    document.addEventListener('keyup', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = false;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = false;
    });
    // --- Mobile Touch Controls ---
    document.getElementById('leftBtn').addEventListener('touchstart', e => { leftPressed = true; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('touchend', e => { leftPressed = false; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('mousedown', e => { leftPressed = true; });
    document.getElementById('leftBtn').addEventListener('mouseup', e => { leftPressed = false; });
    document.getElementById('leftBtn').addEventListener('mouseleave', e => { leftPressed = false; });
    document.getElementById('rightBtn').addEventListener('touchstart', e => { rightPressed = true; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('touchend', e => { rightPressed = false; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('mousedown', e => { rightPressed = true; });
    document.getElementById('rightBtn').addEventListener('mouseup', e => { rightPressed = false; });
    document.getElementById('rightBtn').addEventListener('mouseleave', e => { rightPressed = false; });
    // --- Game Functions ---
    function restartGame() {
      player.x = w/2; player.y = h/2; distance = 0; score = 0; obstacles = [];
      gameOver = false; obstacleInterval = 540; resetControls();
      document.getElementById('gameOverScreen').style.display = 'none';
    }
    document.getElementById('restartBtn').onclick = restartGame;
    function drawRoad() {
  ctx.save();
  // Road background
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, w, h);
  // Subtle road texture
  for (let i = 0; i < h; i += 16) {
    ctx.globalAlpha = 0.07;
    ctx.fillStyle = i % 32 === 0 ? '#aaa' : '#fff';
    ctx.fillRect(w*0.19, i, w*0.62, 2);
  }
  ctx.globalAlpha = 1.0;
  // Main road
  ctx.fillStyle = '#222';
  ctx.fillRect(w*0.19, 0, w*0.62, h);
  // Speed lines for intensity
  for (let i = 0; i < 16; ++i) {
    ctx.globalAlpha = 0.20 + Math.random()*0.10;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.6;
    let lx = w*0.22 + Math.random()*w*0.56;
    let ly = Math.random()*h;
    ctx.beginPath();
    ctx.moveTo(lx, ly);
    ctx.lineTo(lx, ly+22+Math.random()*22);
    ctx.stroke();
  }
  ctx.globalAlpha = 1.0;
  // Solid white edge lines
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(w*0.19, 0);
  ctx.lineTo(w*0.19, h);
  ctx.moveTo(w*0.81, 0);
  ctx.lineTo(w*0.81, h);
  ctx.stroke();
  // Dashed white lane lines (center)
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 3;
  ctx.setLineDash([28, 32]);
  ctx.lineDashOffset = roadScroll;
  ctx.beginPath();
  ctx.moveTo(w/2, 0);
  ctx.lineTo(w/2, h);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}
    function drawPlayer() {
  ctx.save();
  // Car shadow
  ctx.globalAlpha = 0.16;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(player.x, player.y+player.height/2-6, player.width*0.48, 13, 0, 0, 2*Math.PI);
  ctx.fill();
  ctx.globalAlpha = 1.0;
  ctx.shadowColor = '#0ff';
  ctx.shadowBlur = 18;
  // Main car body (arrow shape, facing up)
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.moveTo(player.x, player.y-player.height/2); // nose (top center)
  ctx.lineTo(player.x+player.width/2-8, player.y-player.height/2+22); // right front
  ctx.lineTo(player.x+player.width/2, player.y+player.height/2-10); // right rear
  ctx.lineTo(player.x, player.y+player.height/2); // tail
  ctx.lineTo(player.x-player.width/2, player.y+player.height/2-10); // left rear
  ctx.lineTo(player.x-player.width/2+8, player.y-player.height/2+22); // left front
  ctx.closePath();
  ctx.fill();
  // Windshield
  ctx.globalAlpha = 0.7;
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(player.x-10, player.y-player.height/2+16);
  ctx.lineTo(player.x+10, player.y-player.height/2+16);
  ctx.lineTo(player.x+7, player.y-player.height/2+32);
  ctx.lineTo(player.x-7, player.y-player.height/2+32);
  ctx.closePath();
  ctx.fill();
  ctx.globalAlpha = 1.0;
  // Wheels
  ctx.fillStyle = '#222';
  ctx.fillRect(player.x-16, player.y-18, 7, 21);
  ctx.fillRect(player.x+9, player.y-18, 7, 21);
  ctx.fillRect(player.x-16, player.y+8, 7, 18);
  ctx.fillRect(player.x+9, player.y+8, 7, 18);
  ctx.restore();
}
    function drawObstacle(obs) {
  ctx.save();
  ctx.shadowColor = obs.color;
  ctx.shadowBlur = 8;
  if (obs.type === 'truck') {
    // Truck viewed from behind: main rectangle, tail lights
    ctx.fillStyle = obs.color;
    ctx.fillRect(obs.x-obs.width/2, obs.y-obs.height/2, obs.width, obs.height);
    // Tail lights
    ctx.fillStyle = '#f00';
    ctx.fillRect(obs.x-obs.width/2+3, obs.y+obs.height/2-7, 7, 7);
    ctx.fillRect(obs.x+obs.width/2-10, obs.y+obs.height/2-7, 7, 7);
    // Wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(obs.x-obs.width/2+2, obs.y+obs.height/2-16, 8, 6);
    ctx.fillRect(obs.x+obs.width/2-10, obs.y+obs.height/2-16, 8, 6);
  } else {
    // Car viewed from behind: rounded rectangle, tail lights
    ctx.fillStyle = obs.color;
    ctx.beginPath();
    ctx.ellipse(obs.x, obs.y, obs.width/2, obs.height/2, 0, 0, 2*Math.PI);
    ctx.fill();
    // Tail lights
    ctx.fillStyle = '#f00';
    ctx.fillRect(obs.x-obs.width/2+4, obs.y+obs.height/2-7, 6, 6);
    ctx.fillRect(obs.x+obs.width/2-10, obs.y+obs.height/2-7, 6, 6);
    // Wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(obs.x-obs.width/2+3, obs.y+obs.height/2-14, 6, 5);
    ctx.fillRect(obs.x+obs.width/2-9, obs.y+obs.height/2-14, 6, 5);
  }
  ctx.restore();
}
    function updateObstacles(dt) {
      for (let obs of obstacles) obs.y += obs.speed * dt;
      obstacles = obstacles.filter(obs => obs.y - obs.height/2 < h);
    }
    function spawnObstacle() {
  // Always leave at least one open lane (sometimes two for fairness)
  const lanes = [0, 1, 2];
  // Decide how many lanes to block (1 or 2, never 3)
  let blockCount = Math.random() < 0.7 ? 2 : 1; // More likely to block 2, so 1 lane open
  let openLanes = [];
  while (openLanes.length < (3 - blockCount)) {
    let l = lanes[Math.floor(Math.random()*lanes.length)];
    if (!openLanes.includes(l)) openLanes.push(l);
  }
  let blocked = lanes.filter(l => !openLanes.includes(l));
  // Prevent overlapping: only spawn if no other obstacle is close in the lane
  for (let lane of blocked) {
    const laneX = w*0.3 + lane*w*0.2;
    let tooClose = obstacles.some(o => Math.abs(o.x - laneX) < 10 && o.y < 120);
    if (tooClose) continue;
    // 60% truck, 40% car
    if (Math.random() < 0.6) {
      obstacles.push({
        x: laneX, y: -60, width: 38, height: 88+Math.random()*18,
        speed: 16 + Math.random()*4 + distance/60, // trucks even faster
        color: '#ff0', type: 'truck'
      });
    } else {
      obstacles.push({
        x: laneX, y: -40, width: 28, height: 38+Math.random()*8, // cars are narrower
        speed: 14 + Math.random()*4 + distance/90, // cars faster
        color: ['#f33','#0ff','#0f0'][Math.floor(Math.random()*3)], type: 'car'
      });
    }
  }
}
    function checkCollision(a, b) {
      return Math.abs(a.x-b.x) < (a.width+b.width)/2 && Math.abs(a.y-b.y) < (a.height+b.height)/2;
    }
    function update(dt) {
  applyShake(dt); // update shake

  roadScroll -= player.speed * 2.6 * dt;
  if (roadScroll < -60) roadScroll += 60; // Make lane dashes scroll UP for forward feel
      // Player movement
      if (leftPressed) player.x -= player.speed;
      if (rightPressed) player.x += player.speed;
      // Clamp to road
      player.x = Math.max(w*0.21 + player.width/2, Math.min(w*0.79 - player.width/2, player.x));
      // Obstacles
      updateObstacles(dt);
      // Spawn
      obstacleTimer += dt*1000;
      if (obstacleTimer > obstacleInterval) {
        obstacleTimer = 0;
        spawnObstacle();
        if (obstacleInterval > minInterval) obstacleInterval -= 3.5; // ramp up faster
      }
      // Collision
      for (let obs of obstacles) {
  if (checkCollision(player, obs)) {
  if (obs.type === 'truck') {
    // Truck collision: game over
    triggerShake(1.7);
    gameOver = true;
    document.getElementById('finalScore').textContent = Math.floor(distance);
    document.getElementById('gameOverScreen').style.display = 'flex';
    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem('nightdriver_best', bestScore);
    }
    document.getElementById('bestScore').textContent = bestScore;
  } else if (obs.type === 'car') {
    // Car collision: strong shake and penalty, but NOT game over
    triggerShake(1.2);
    score = Math.max(0, score - 25);
    obs.x += (Math.random() > 0.5 ? 1 : -1) * 40; // nudge car aside
    obs.y -= 18; // push away
  }
}
  // Near-miss detection (side-by-side, but not colliding)
  else if (!gameOver && Math.abs(player.y-obs.y) < (player.height+obs.height)/2+16 && Math.abs(player.x-obs.x) > (player.width+obs.width)/2 && Math.abs(player.x-obs.x) < (player.width+obs.width)/2+18) {
    // Only trigger once per obstacle
    if (!obs.nearMissed) {
      obs.nearMissed = true;
      triggerShake();
      score += 10; // bonus points
    }
  }
}
      // Score
      if (!gameOver) {
        // Increase speed as you go further
  player.speed = 10.5 + Math.min(18, distance/110);
  distance += dt*player.speed*2.25;
  score = Math.floor(distance);
  document.getElementById('score').textContent = score;
  // Make obstacles spawn faster as you go
  obstacleInterval = Math.max(minInterval, 700 - distance/2);
      }
    }
    
    function draw(dt) {
  // 1. Starfield background
  drawStars(dt);
  // 2. Road and lane lines
  drawRoad();
  // 3. Headlight cone
  drawHeadlights();
  // 4. Shake effect: only apply to player & obstacles
  let dx = 0;
  if (shake > 0) dx = (Math.random()-0.5)*shake;
  ctx.save();
  ctx.translate(dx, 0);
  drawPlayer();
  for (let obs of obstacles) drawObstacle(obs);
  ctx.restore();
}
    // --- Main Loop ---
    let last = performance.now();
function loop(now) {
  let dt = Math.min(0.06, (now-last)/1000);
  last = now;
  if (!gameOver) update(dt);
  draw(dt);
  requestAnimationFrame(loop);
}
    // --- Init ---
    function init() {
      bestScore = Number(localStorage.getItem('nightdriver_best')) || 0;
      document.getElementById('bestScore').textContent = bestScore;
      restartGame();
      roadScroll = 0;
      requestAnimationFrame(loop);
    }
    init();
  </script>
</body>
</html>
