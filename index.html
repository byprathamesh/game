<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Night Driver</title>
  <meta name="description" content="Night Driver: A neon endless racer game. Dodge obstacles, rack up your score, and enjoy retro visuals!">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Press Start 2P', 'VT323', 'Consolas', monospace;
    }
    body {
      overflow: hidden;
    }
    #gameContainer {
      background: #000;
      box-shadow: 0 0 0 8px #181818;
      border: 4px solid #444;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 360px;
      height: 640px;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      overflow: hidden;
    }
    #gameContainer {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 360px;
      height: 640px;
      background: #222;
      box-shadow: 0 0 0 8px #181818;
      border: 4px solid #444;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #gameCanvas {
      display: block;
      background: #222;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      width: 320px;
      height: 480px;
      border: 0;
      margin: 0;
      box-shadow: none;
    }
    #hud {
      position: absolute;
      top: 8px;
      left: 0;
      width: 100%;
      text-align: center;
      color: #fff;
      font-size: 12px;
      z-index: 2;
      pointer-events: none;
      text-shadow: none;
    }
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(34,34,34,0.98);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 3;
      font-size: 18px;
      color: #fff;
      border: 0;
    }
    #gameOverScreen button {
      margin-top: 28px;
      font-size: 13px;
      background: #444;
      border: 2px solid #888;
      color: #fff;
      padding: 10px 28px;
      border-radius: 0;
      box-shadow: none;
      font-family: 'Press Start 2P', monospace;
      cursor: pointer;
    }
    #mobileControls {
      position: absolute;
      bottom: 38px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      z-index: 4;
      pointer-events: auto;
      gap: 16px;
    }
    .ctrl-btn {
      width: 52px;
      height: 52px;
      font-size: 32px;
      background: #444;
      color: #fff;
      border: 4px solid #222;
      border-radius: 0;
      box-shadow: none;
      font-family: 'Press Start 2P', monospace;
      cursor: pointer;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.1s;
    }
    .ctrl-btn:active {
      background: #666;
    }
    @media (max-width: 500px) {
      #gameContainer {
        width: 100vw;
        height: 100vh;
        min-width: 0;
        min-height: 0;
        border-width: 0;
        box-shadow: none;
      }
      #gameCanvas {
        width: 100vw;
        height: 100vw;
        max-width: 100vw;
        max-height: 100vw;
      }
    }
  </style>
  <script>
    // Responsive resize logic to maintain 360x640 aspect ratio
    function resizeGame() {
      const aspect = 360 / 640;
      let w = window.innerWidth;
      let h = window.innerHeight;
      if (w / h > aspect) {
        w = h * aspect;
      } else {
        h = w / aspect;
      }
      const container = document.getElementById('gameContainer');
      container.style.width = w + 'px';
      container.style.height = h + 'px';
      const canvas = container.querySelector('canvas');
      if (canvas) {
        canvas.width = 320;
        canvas.height = 480;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
      }
    }
  </script>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="320" height="480" style="width: 100vw; height: 100vh; image-rendering: pixelated; image-rendering: crisp-edges; background: #181818; display: block; margin: 0 auto;"></canvas>
    <div id="hud">
      <span id="score">0</span> m
      <span style="margin-left:16px; font-size:0.9em;">Best: <span id="bestScore">0</span></span>
    </div>
    <div id="gameOverScreen">
      <div style="margin-top: 120px;">Game Over<br><span id="finalScore">0</span> m</div>
      <button id="restartBtn">Restart</button>
    </div>
    <div id="mobileControls">
      <button class="ctrl-btn" id="leftBtn">⟵</button>
      <button class="ctrl-btn" id="rightBtn">⟶</button>
    </div>
  </div>
  <script>
    // --- Texture loading (must be global and first) ---
    const textures = {
      grass: new Image(),
      dirt: new Image(),
      stone: new Image()
    };
    textures.grass.src = 'textures/grass.png';
    textures.dirt.src = 'textures/dirt.png';
    textures.stone.src = 'textures/stone.png';

    // --- Game Constants ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    let roadScroll = 0;

    // --- Starfield ---
    function drawStarfield() {
      // Draw blocky "sky" background (like Minecraft)
      ctx.fillStyle = '#000'; // Deep night sky
      ctx.fillRect(0, 0, w, h);
      // Draw blocky stars
      for (let i = 0; i < 24; i++) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(Math.floor(Math.random()*320), Math.floor(Math.random()*480), 2, 2);
      }
    }

    // --- Headlight effect ---
    function drawHeadlights() {
      // No headlight effect in Minecraft style
    }

    // --- Near-miss shake ---
    let shake = 0, shakeTimer = 0;
    function triggerShake(intensity=1) {
      shake = 18 * intensity;
      shakeTimer = 0.22 * intensity;
    }
    function applyShake(dt) {
      if (shake > 0) {
        shakeTimer -= dt;
        if (shakeTimer < 0) shake = 0;
      }
    }

    // --- Game State ---
    const NUM_LANES = 3;
    let laneCenters = [];
    function updateLaneCenters() {
      laneCenters = [];
      // Road from w * 0.18 to w * 0.82 for more space, evenly spaced for 3 lanes
      let roadLeft = w * 0.18;
      let roadRight = w * 0.82;
      let laneWidth = (roadRight - roadLeft) / 3;
      for (let i = 0; i < 3; i++) {
        laneCenters.push(roadLeft + laneWidth/2 + i * laneWidth);
      }
    }
    updateLaneCenters();
    let player = { x: laneCenters[1], y: h/2, width: 38, height: 64, speed: 15, color: '#0ff' }; // Start in center lane
    let obstacles = [], obstacleTimer = 0, obstacleInterval = 180, minInterval = 60;
    let distance = 0, score = 0, bestScore = 0;
    let speedMultiplier = 1;
    let gameOver = false;
    let leftPressed = false, rightPressed = false;
    // --- Controls ---
    function resetControls() { leftPressed = rightPressed = false; }
    document.addEventListener('keydown', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = true;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = true;
      if (gameOver && (e.key===' '||e.key==='Enter')) restartGame();
    });
    document.addEventListener('keyup', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = false;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = false;
    });
    // --- Mobile Touch Controls ---
    document.getElementById('leftBtn').addEventListener('touchstart', e => { leftPressed = true; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('touchend', e => { leftPressed = false; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('mousedown', e => { leftPressed = true; });
    document.getElementById('leftBtn').addEventListener('mouseup', e => { leftPressed = false; });
    document.getElementById('leftBtn').addEventListener('mouseleave', e => { leftPressed = false; });
    document.getElementById('rightBtn').addEventListener('touchstart', e => { rightPressed = true; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('touchend', e => { rightPressed = false; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('mousedown', e => { rightPressed = true; });
    document.getElementById('rightBtn').addEventListener('mouseup', e => { rightPressed = false; });
    document.getElementById('rightBtn').addEventListener('mouseleave', e => { rightPressed = false; });
    // --- Game Functions ---
    function restartGame() {
      player.x = w/2; player.y = h/2; distance = 0; score = 0; obstacles = [];
      gameOver = false;
      obstacleInterval = 180; // Fast spawn
      obstacleTimer = obstacleInterval; // Spawn first truck immediately
      resetControls();
      document.getElementById('gameOverScreen').style.display = 'none';
    }
    document.getElementById('restartBtn').onclick = restartGame;
    // (removed duplicate declaration and code, only one starfield system remains)

    function drawRoad() {
      ctx.save();

      // --- Road (blocky stone) ---
      if (textures.stone.complete && textures.stone.naturalWidth) {
        for (let y = 0; y < h; y += 16) {
          for (let x = w * 0.21; x < w * 0.79; x += 16) ctx.drawImage(textures.stone, x, y, 16, 16);
        }
      } else {
        ctx.fillStyle = '#888';
        ctx.fillRect(w * 0.21, 0, w * 0.58, h);
      }
      // --- Lane markings (blocky white lines) ---
      ctx.fillStyle = '#fff';
      let roadLeft = Math.round(w * 0.21);
      let roadRight = Math.round(w * 0.79);
      let laneWidth = Math.round((roadRight - roadLeft) / 3);
      for (let i = 1; i < 3; i++) {
        let x = Math.round(roadLeft + i * laneWidth);
        // Reverse direction: stripes move downward
        for (let y = (roadScroll % 32) - 32; y < h; y += 32) ctx.fillRect(x - 2, y, 4, 20);
      }
      // --- Road edge lines (blocky) ---
      ctx.fillStyle = '#222';
      ctx.fillRect(roadLeft - 4, 0, 4, h);
      ctx.fillRect(roadRight, 0, 4, h);
      ctx.restore();
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(Math.round(player.x), Math.round(player.y));
      // --- Car Body ---
      ctx.fillStyle = '#232323'; // dark body
      ctx.fillRect(-14, -20, 28, 40);
      // --- Blue Window ---
      ctx.fillStyle = '#5a8fd6';
      ctx.fillRect(-10, -14, 20, 10);
      // --- Headlights ---
      ctx.fillStyle = '#fff';
      ctx.fillRect(-8, -22, 6, 4);
      ctx.fillRect(2, -22, 6, 4);
      // --- Taillights ---
      ctx.fillStyle = '#ff3c28';
      ctx.fillRect(-8, 20, 6, 4);
      ctx.fillRect(2, 20, 6, 4);
      // --- Grill ---
      ctx.fillStyle = '#666';
      ctx.fillRect(-4, -20, 8, 3);
      // --- Wheels ---
      ctx.fillStyle = '#111';
      ctx.fillRect(-14, 14, 6, 8);
      ctx.fillRect(8, 14, 6, 8);
      ctx.fillRect(-14, -18, 6, 8);
      ctx.fillRect(8, -18, 6, 8);
      ctx.restore();
    }

    function drawObstacle(obs) {
      ctx.save();
      ctx.translate(Math.round(obs.x), Math.round(obs.y));
      // --- Truck Body ---
      ctx.fillStyle = '#b97a57'; // brown
      ctx.fillRect(-16, -32, 32, 64);
      // --- Truck Cabin ---
      ctx.fillStyle = '#cfcfcf';
      ctx.fillRect(-12, -32, 24, 18);
      // --- Truck Grill ---
      ctx.fillStyle = '#888';
      ctx.fillRect(-8, -32, 16, 4);
      // --- Headlights ---
      ctx.fillStyle = '#ffe066';
      ctx.fillRect(-14, -32, 6, 4);
      ctx.fillRect(8, -32, 6, 4);
      // --- Taillights ---
      ctx.fillStyle = '#ff3c28';
      ctx.fillRect(-14, 28, 6, 4);
      ctx.fillRect(8, 28, 6, 4);
      // --- Wheels ---
      ctx.fillStyle = '#222';
      ctx.fillRect(-16, 24, 8, 8);
      ctx.fillRect(8, 24, 8, 8);
      ctx.restore();
    }

    function updateObstacles(dt) {
      for (let obs of obstacles) obs.y += obs.speed * dt * speedMultiplier;
      obstacles = obstacles.filter(obs => obs.y - obs.height/2 < h);
    }

    function spawnObstacle() {
      // Only spawn trucks, never cars
      const lanes = [0, 1, 2];
      // Randomly choose 1 or 2 lanes to block, always leave at least 1 open
      let lanesToBlock = lanes.slice();
      // Shuffle
      for (let i = lanesToBlock.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [lanesToBlock[i], lanesToBlock[j]] = [lanesToBlock[j], lanesToBlock[i]];
      }
      // Randomly decide to block 1 or 2 lanes
      let blocks = Math.floor(Math.random() * 2) + 1;
      lanesToBlock = lanesToBlock.slice(0, blocks);
      const spawnY = -80;
      for (let lane = 0; lane < 3; lane++) {
        if (!lanesToBlock.includes(lane)) continue;
        const laneX = laneCenters[lane];
        let laneBlocked = obstacles.some(o => o.lane === lane && o.y < h && o.y > -120);
        if (laneBlocked) continue;
        obstacles.push({
          x: laneX,
          y: spawnY,
          lane,
          width: 32,
          height: 64,
          speed: 8 + Math.random() * 2,
          type: 'truck'
        });
      }
    }


document.getElementById('bestScore').textContent = bestScore;

if (!window.DEBUG_ONCE_DRAW) { console.log('DRAW RUNNING'); window.DEBUG_ONCE_DRAW = true; }
drawStarfield();
drawRoad();
drawHeadlights();
let dx = 0;
if (shake > 0) dx = (Math.random()-0.5)*shake;
ctx.save();
ctx.translate(dx, 0);
drawPlayer();
for (let obs of obstacles) drawObstacle(obs);
ctx.restore();


// --- Update Logic ---
function update(dt) {
  // Move player left/right if keys are pressed
  if (!gameOver) {
    // Progress distance and score
    distance += dt * 200; // Tune speed as needed
    score = Math.floor(distance);

    // Scroll road
    roadScroll += dt * 320 * 0.5; // Adjust speed as needed

    if (leftPressed) player.x -= player.speed * dt * 60;
    if (rightPressed) player.x += player.speed * dt * 60;
    // Clamp player to road bounds
    player.x = Math.max(laneCenters[0], Math.min(laneCenters[2], player.x));

    // Spawn trucks at intervals
    obstacleTimer += dt * 1000;
    if (obstacleTimer >= obstacleInterval) {
      spawnObstacle();
      obstacleTimer = 0;
    }
  }
  // Update obstacles
  // Move obstacles, increase speed as distance increases, and despawn off-screen
  for (let obs of obstacles) {
    obs.y += obs.speed * dt * (1 + distance/1000);
  }
  obstacles = obstacles.filter(obs => obs.y - obs.height/2 < h);

  // Collision detection
  for (let obs of obstacles) {
    if (
      Math.abs(player.x - obs.x) < (player.width + obs.width) / 2 &&
      Math.abs(player.y - obs.y) < (player.height + obs.height) / 2
    ) {
      gameOver = true;
      // Update best score if needed
      if (score > bestScore) {
        bestScore = score;
        try {
          localStorage.setItem('nightdriver_best', bestScore);
        } catch (e) {
          // Storage not available
        }
      }
      document.getElementById('gameOverScreen').style.display = 'block';
      break;
    }
  }

  // Make truck spawn interval decrease faster as you go
  obstacleInterval = Math.max(minInterval, 180 - distance/3);
}

// --- Main Loop ---
let last = performance.now(); // Only ONE declaration allowed, before loop()
function loop(now) {
  if (window.DEBUG_ONCE_LOOP !== true) {
    console.log('LOOP RUNNING');
    window.DEBUG_ONCE_LOOP = true;
  }
  let dt = Math.min(0.06, (now-last)/1000);
  last = now;
  if (!gameOver) update(dt);
  draw(dt);
  requestAnimationFrame(loop);
}

// --- Init ---
function init() {
  console.log('INIT CALLED');
  try {
  bestScore = Number(localStorage.getItem('nightdriver_best')) || 0;
} catch (e) {
  bestScore = 0;
}
  document.getElementById('bestScore').textContent = bestScore;
  restartGame();
  roadScroll = 0;
  requestAnimationFrame(loop);
}
init();

// Ensure all functions and variables are defined before these listeners
window.addEventListener('resize', () => {
  resizeGame();
  updateLaneCenters();
  player.x = laneCenters[1]; // center lane
});
document.addEventListener('DOMContentLoaded', () => {
  resizeGame();
  updateLaneCenters();
  player.x = laneCenters[1]; // center lane
});

// --- END OF GAME SCRIPT ---
</script>
</body>
</html>
    document.getElementById('bestScore').textContent = bestScore;
  } else if (obs.type === 'car') {
    // Car collision: penalty, but NOT game over (no shake)
        score = Math.max(0, score - 25);
        obs.x += (Math.random() > 0.5 ? 1 : -1) * 40; // nudge car aside
        obs.y -= 18; // push away
  }
}
  // Near-miss detection (side-by-side, but not colliding)
      else if (!gameOver && Math.abs(player.y-obs.y) < (player.height+obs.height)/2+16 && Math.abs(player.x-obs.x) > (player.width+obs.width)/2 && Math.abs(player.x-obs.x) < (player.width+obs.width)/2+18) {
        // Only trigger once per obstacle
        if (!obs.nearMissed) {
          obs.nearMissed = true;
          score += 10; // bonus points
        }
      }
    }
  }
  // Make obstacles spawn faster as you go
  obstacleInterval = Math.max(minInterval, 420 - distance);
function draw(dt) {
  document.getElementById('score').textContent = score + ' m';
  document.getElementById('bestScore').textContent = bestScore;

  if (!window.DEBUG_ONCE_DRAW) { console.log('DRAW RUNNING'); window.DEBUG_ONCE_DRAW = true; }
  // 1. Road, neon background, starfield, etc.
  drawRoad();
  // 2. Headlight cone
  drawHeadlights();
  // 3. Shake effect: only apply to player & obstacles
  let dx = 0;
  if (shake > 0) dx = (Math.random()-0.5)*shake;
  ctx.save();
  ctx.translate(dx, 0);
  drawPlayer();
  for (let obs of obstacles) drawObstacle(obs);
  ctx.restore();
}
// --- END OF GAME SCRIPT ---
</script>
</body>
</html>
