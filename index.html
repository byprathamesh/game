<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Night Driver</title>
  <meta name="description" content="Night Driver: A neon endless racer game. Dodge obstacles, rack up your score, and enjoy retro visuals!">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #101020 60%, #000 100%);
      min-height: 100vh;
      font-family: 'Segoe UI', Arial, sans-serif;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      box-shadow: 0 0 32px #0ff8, 0 0 8px #00f4, 0 0 0 #000;
      border-radius: 18px;
      overflow: hidden;
      background: #111;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
      aspect-ratio: 9/16;
      max-width: 100vw;
      max-height: 100vh;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 1.3rem;
      letter-spacing: 1px;
      z-index: 2;
      user-select: none;
      text-shadow: 0 0 4px #0ff, 0 0 8px #00f, 0 0 2px #fff;
    }
    #gameOverScreen {
      display: none;
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(10,10,40,0.92);
      color: #fff;
      z-index: 10;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      text-shadow: 0 0 8px #0ff, 0 0 2px #fff;
    }
    #gameOverScreen button {
      margin-top: 24px;
      padding: 12px 32px;
      font-size: 1.2rem;
      border-radius: 8px;
      border: none;
      background: linear-gradient(90deg,#0ff,#08f 80%);
      color: #111;
      font-weight: bold;
      box-shadow: 0 0 8px #0ff;
      cursor: pointer;
    }
    #mobileControls {
      position: absolute;
      bottom: 18px;
      left: 0;
      width: 100%;
      display: flex;
      flex-direction: row;
      justify-content: center;
      gap: 32px;
      z-index: 3;
      pointer-events: none;
    }
    .ctrl-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(0,255,255,0.12);
      border: 2px solid #0ff;
      color: #0ff;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px #0ff8;
      pointer-events: auto;
      user-select: none;
      touch-action: none;
      transition: background 0.2s;
    }
    .ctrl-btn:active {
      background: rgba(0,255,255,0.32);
    }
    @media (max-width: 500px) {
      #gameContainer { width: 98vw; height: 70vw; min-height: 320px; }
    }
  </style>
<script>
// Responsive resize logic to maintain 360x640 aspect ratio
function resizeGame() {
  const aspect = 360 / 640;
  let w = window.innerWidth;
  let h = window.innerHeight;
  if (w / h > aspect) {
    w = h * aspect;
  } else {
    h = w / aspect;
  }
  const container = document.getElementById('gameContainer');
  container.style.width = w + 'px';
  container.style.height = h + 'px';
  const canvas = container.querySelector('canvas');
  if (canvas) {
    canvas.width = 360;
    canvas.height = 640;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
}

</script>

</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="360" height="640"></canvas>
    <div id="hud">
      <span id="score">0</span> m
      <span style="margin-left:16px; font-size:0.9em;">Best: <span id="bestScore">0</span></span>
    </div>
    <div id="gameOverScreen">
      <div style="margin-top: 120px;">Game Over<br><span id="finalScore">0</span> m</div>
      <button id="restartBtn">Restart</button>
    </div>
    <div id="mobileControls">
      <button class="ctrl-btn" id="leftBtn">⟵</button>
      <button class="ctrl-btn" id="rightBtn">⟶</button>
    </div>
  </div>
  <script>
    // --- Game Constants ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    let roadScroll = 0;

    // --- Starfield ---
    let stars = [];
    function initStars() {
      stars = [];
      for (let i = 0; i < 64; i++) {
        stars.push({
          x: Math.random() * w,
          y: Math.random() * h,
          speed: 0.3 + Math.random() * 1.1
        });
      }
    }
    initStars();
    function drawStarfield(dt) {
      ctx.save();
      for (let star of stars) {
        ctx.globalAlpha = 0.5 + Math.random()*0.2;
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(star.x, star.y, 1.2 + Math.random()*1, 0, 2*Math.PI);
        ctx.fill();
        star.y += star.speed * dt * 60;
        if (star.y > h) {
          star.y = 0;
          star.x = Math.random() * w;
        }
      }
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }

    // --- Headlight effect ---
    function drawHeadlights() {
      ctx.save();
      ctx.globalAlpha = 0.22;
      const grad = ctx.createRadialGradient(player.x, player.y-20, 16, player.x, player.y-120, 160);
      grad.addColorStop(0, '#fff8');
      grad.addColorStop(0.1, '#0ff6');
      grad.addColorStop(0.4, '#0ff2');
      grad.addColorStop(1, 'transparent');
      ctx.beginPath();
      ctx.ellipse(player.x, player.y-60, 70, 170, 0, 0, 2*Math.PI);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }

    // --- Near-miss shake ---
    let shake = 0, shakeTimer = 0;
    function triggerShake(intensity=1) {
  shake = 18 * intensity;
  shakeTimer = 0.22 * intensity;
}
    function applyShake(dt) {
      if (shake > 0) {
        shakeTimer -= dt;
        if (shakeTimer < 0) shake = 0;
      }
    }

    // --- Game State ---
    const NUM_LANES = 3;
let laneCenters = [];
function updateLaneCenters() {
  laneCenters = [];
  // Road from w * 0.21 to w * 0.79, evenly spaced for 3 lanes
  let roadLeft = w * 0.21;
  let roadRight = w * 0.79;
  let laneWidth = (roadRight - roadLeft) / 3; // 3 lanes, 2 dashed lines
  for (let i = 0; i < 3; i++) {
    laneCenters.push(roadLeft + laneWidth/2 + i * laneWidth);
  }
}
updateLaneCenters();
let player = { x: laneCenters[1], y: h/2, width: 38, height: 64, speed: 15, color: '#0ff' }; // Start in center lane
    let obstacles = [], obstacleTimer = 0, obstacleInterval = 540, minInterval = 90;
    let distance = 0, score = 0, bestScore = 0;
    let speedMultiplier = 1;
    let gameOver = false;
    let leftPressed = false, rightPressed = false;
    // --- Controls ---
    function resetControls() { leftPressed = rightPressed = false; }
    document.addEventListener('keydown', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = true;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = true;
      if (gameOver && (e.key===' '||e.key==='Enter')) restartGame();
    });
    document.addEventListener('keyup', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = false;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = false;
    });
    // --- Mobile Touch Controls ---
    document.getElementById('leftBtn').addEventListener('touchstart', e => { leftPressed = true; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('touchend', e => { leftPressed = false; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('mousedown', e => { leftPressed = true; });
    document.getElementById('leftBtn').addEventListener('mouseup', e => { leftPressed = false; });
    document.getElementById('leftBtn').addEventListener('mouseleave', e => { leftPressed = false; });
    document.getElementById('rightBtn').addEventListener('touchstart', e => { rightPressed = true; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('touchend', e => { rightPressed = false; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('mousedown', e => { rightPressed = true; });
    document.getElementById('rightBtn').addEventListener('mouseup', e => { rightPressed = false; });
    document.getElementById('rightBtn').addEventListener('mouseleave', e => { rightPressed = false; });
    // --- Game Functions ---
    function restartGame() {
      player.x = w/2; player.y = h/2; distance = 0; score = 0; obstacles = [];
      gameOver = false; obstacleInterval = 540; resetControls();
      document.getElementById('gameOverScreen').style.display = 'none';
    }
    document.getElementById('restartBtn').onclick = restartGame;
    // (removed duplicate declaration and code, only one starfield system remains)

function drawRoad() {
  ctx.save();
  // Neon gradient background
  let grad = ctx.createLinearGradient(0, 0, 0, h);
  grad.addColorStop(0, '#0ff8');
  grad.addColorStop(0.5, '#181e3c');
  grad.addColorStop(1, '#000');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, w, h);
  // Animated starfield
  drawStarfield(1);
  // Glowing road
  ctx.save();
  ctx.shadowColor = '#0ff';
  ctx.shadowBlur = 36;
  ctx.fillStyle = '#222';
  ctx.fillRect(w*0.21, 0, w*0.58, h);
  ctx.restore();
  // Animated road texture
  let scrollOffset = roadScroll % 32;
  for (let i = -32; i < h; i += 32) {
    ctx.fillStyle = i % 64 === 0 ? '#181818' : '#191919';
    ctx.fillRect(w*0.21, i + scrollOffset, w*0.58, 16);
  }
  // Lane markings (2 dashed lines for 3 lanes)
  ctx.save();
  ctx.shadowColor = '#0ff8';
  ctx.shadowBlur = 12;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 4;
  ctx.setLineDash([32, 32]);
  let roadLeft = w * 0.21;
  let roadRight = w * 0.79;
  let laneWidth = (roadRight - roadLeft) / 3;
  for (let i = 1; i < 3; i++) {
    let x = roadLeft + i * laneWidth;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
    ctx.stroke();
  }
  ctx.restore();
  // Road edge lines
  ctx.save();
  ctx.shadowColor = '#0ff8';
  ctx.shadowBlur = 16;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 7;
  ctx.beginPath();
  ctx.moveTo(w*0.21, 0);
  ctx.lineTo(w*0.21, h);
  ctx.moveTo(w*0.79, 0);
  ctx.lineTo(w*0.79, h);
  ctx.moveTo(w/2, 0);
  ctx.lineTo(w/2, h);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}
    function drawPlayer() {
  ctx.save();
  // Car shadow
  ctx.globalAlpha = 0.16;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(player.x, player.y+player.height/2-6, player.width*0.48, 13, 0, 0, 2*Math.PI);
  ctx.fill();
  ctx.globalAlpha = 1.0;
  ctx.shadowColor = '#0ff';
  ctx.shadowBlur = 18;
  // Main car body (arrow shape, facing up)
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.moveTo(player.x, player.y-player.height/2); // nose (top center)
  ctx.lineTo(player.x+player.width/2-8, player.y-player.height/2+22); // right front
  ctx.lineTo(player.x+player.width/2, player.y+player.height/2-10); // right rear
  ctx.lineTo(player.x, player.y+player.height/2); // tail
  ctx.lineTo(player.x-player.width/2, player.y+player.height/2-10); // left rear
  ctx.lineTo(player.x-player.width/2+8, player.y-player.height/2+22); // left front
  ctx.closePath();
  ctx.fill();
  // Windshield
  ctx.globalAlpha = 0.7;
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(player.x-10, player.y-player.height/2+16);
  ctx.lineTo(player.x+10, player.y-player.height/2+16);
  ctx.lineTo(player.x+7, player.y-player.height/2+32);
  ctx.lineTo(player.x-7, player.y-player.height/2+32);
  ctx.closePath();
  ctx.fill();
  ctx.globalAlpha = 1.0;
  // Wheels
  ctx.fillStyle = '#222';
  ctx.fillRect(player.x-16, player.y-18, 7, 21);
  ctx.fillRect(player.x+9, player.y-18, 7, 21);
  ctx.fillRect(player.x-16, player.y+8, 7, 18);
  ctx.fillRect(player.x+9, player.y+8, 7, 18);
  ctx.restore();
}
    function drawObstacle(obs) {
  ctx.save();
  ctx.shadowColor = obs.color;
  ctx.shadowBlur = 10;
  if (obs.type === 'truck') {
    // Truck viewed from front: big rectangle, headlights, grill
    ctx.fillStyle = obs.color;
    ctx.fillRect(obs.x-obs.width/2, obs.y-obs.height/2, obs.width, obs.height);
    // Headlights
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.82;
    ctx.fillRect(obs.x-obs.width/2+3, obs.y-obs.height/2+4, 8, 8);
    ctx.fillRect(obs.x+obs.width/2-11, obs.y-obs.height/2+4, 8, 8);
    ctx.globalAlpha = 1.0;
    // Grill
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(obs.x-obs.width/2+7, obs.y+obs.height/2-7);
    ctx.lineTo(obs.x+obs.width/2-7, obs.y+obs.height/2-7);
    ctx.stroke();
    // Wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(obs.x-obs.width/2+2, obs.y+obs.height/2-12, 8, 6);
    ctx.fillRect(obs.x+obs.width/2-10, obs.y+obs.height/2-12, 8, 6);
  } else {
    // Car viewed from front: narrow rectangle, headlights, grill
    ctx.fillStyle = obs.color;
    ctx.fillRect(obs.x-obs.width/2, obs.y-obs.height/2, obs.width, obs.height);
    // Headlights
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.82;
    ctx.fillRect(obs.x-obs.width/2+1, obs.y-obs.height/2+3, 5, 6);
    ctx.fillRect(obs.x+obs.width/2-6, obs.y-obs.height/2+3, 5, 6);
    ctx.globalAlpha = 1.0;
    // Grill
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(obs.x-obs.width/2+3, obs.y+obs.height/2-5);
    ctx.lineTo(obs.x+obs.width/2-3, obs.y+obs.height/2-5);
    ctx.stroke();
    // Wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(obs.x-obs.width/2+1, obs.y+obs.height/2-10, 4, 4);
    ctx.fillRect(obs.x+obs.width/2-5, obs.y+obs.height/2-10, 4, 4);
  }
  ctx.restore();
}
    function updateObstacles(dt) {
  for (let obs of obstacles) obs.y += obs.speed * dt * speedMultiplier;
  obstacles = obstacles.filter(obs => obs.y - obs.height/2 < h);
}
    function spawnObstacle() {
  // Always leave at least one open lane, and only one obstacle per lane
  const lanes = [0, 1, 2];
  // Randomly pick one lane to remain open
  let openLane = lanes[Math.floor(Math.random() * lanes.length)];
  const spawnY = -80;
  for (let lane = 0; lane < NUM_LANES; lane++) {
    if (lane === openLane) continue;
    const laneX = laneCenters[lane]; // obstacles always centered in lane
    // Only spawn if no obstacle is already in this lane and visible
    let laneBlocked = obstacles.some(o => o.lane === lane && o.y < h && o.y > -120);
    if (laneBlocked) continue;
    if (Math.random() < 0.6) {
      obstacles.push({
        x: laneX, y: spawnY, width: 36, height: 88 + Math.random() * 12,
        speed: (16 + Math.random() * 4 + distance / 60) * speedMultiplier,
        color: '#ff0', type: 'truck', lane: lane
      });
    } else {
      obstacles.push({
        x: laneX, y: spawnY, width: 16, height: 32 + Math.random() * 6,
        speed: (14 + Math.random() * 4 + distance / 90) * speedMultiplier,
        color: ['#f33', '#0ff', '#0f0'][Math.floor(Math.random() * 3)], type: 'car', lane: lane
      });
    }
  }
}

function checkCollision(a, b) {
  return Math.abs(a.x-b.x) < (a.width+b.width)/2 && Math.abs(a.y-b.y) < (a.height+b.height)/2;
}

function update(dt) {
  if (!window.DEBUG_ONCE_UPDATE) { console.log('UPDATE RUNNING'); window.DEBUG_ONCE_UPDATE = true; }
  applyShake(dt); // update shake
  speedMultiplier = 1 + distance / 900;
  let effectiveSpeed = player.speed * speedMultiplier;
  roadScroll -= effectiveSpeed * 2.6 * dt;
  if (roadScroll < -60) roadScroll += 60;
  const lateralSpeed = 5;
  if (leftPressed) player.x -= lateralSpeed;
  if (rightPressed) player.x += lateralSpeed;
  let minX = laneCenters[0] - (laneCenters[1] - laneCenters[0])/2 + player.width/2;
  let maxX = laneCenters[NUM_LANES-1] + (laneCenters[1] - laneCenters[0])/2 - player.width/2;
  player.x = Math.max(minX, Math.min(maxX, player.x));
  updateObstacles(dt);
  obstacleTimer += dt*1000 / speedMultiplier;
  if (obstacleTimer > obstacleInterval) {
    obstacleTimer = 0;
    spawnObstacle();
    if (obstacleInterval > minInterval) obstacleInterval -= 3.5 * speedMultiplier;
  }
  for (let obs of obstacles) {
    if (checkCollision(player, obs)) {
      if (obs.type === 'truck') {
        triggerShake(1.7);
        gameOver = true;
        document.getElementById('finalScore').textContent = Math.floor(distance);
        document.getElementById('gameOverScreen').style.display = 'flex';
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem('nightdriver_best', bestScore);
        }
        document.getElementById('bestScore').textContent = bestScore;
      } else if (obs.type === 'car') {
        score = Math.max(0, score - 25);
        obs.x += (Math.random() > 0.5 ? 1 : -1) * 40;
        obs.y -= 18;
      }
    } else if (!gameOver && Math.abs(player.y-obs.y) < (player.height+obs.height)/2+16 && Math.abs(player.x-obs.x) > (player.width+obs.width)/2 && Math.abs(player.x-obs.x) < (player.width+obs.width)/2+18) {
      if (!obs.nearMissed) {
        obs.nearMissed = true;
        score += 10;
      }
    }
  }
  obstacleInterval = Math.max(minInterval, 700 - distance/2);
}

function draw(dt) {
  if (!window.DEBUG_ONCE_DRAW) { console.log('DRAW RUNNING'); window.DEBUG_ONCE_DRAW = true; }
  drawRoad();
  drawHeadlights();
  let dx = 0;
  if (shake > 0) dx = (Math.random()-0.5)*shake;
  ctx.save();
  ctx.translate(dx, 0);
  drawPlayer();
  for (let obs of obstacles) drawObstacle(obs);
  ctx.restore();
}

// --- Main Loop ---
let last = performance.now(); // Only ONE declaration allowed, before loop()
function loop(now) {
  if (window.DEBUG_ONCE_LOOP !== true) {
    console.log('LOOP RUNNING');
    window.DEBUG_ONCE_LOOP = true;
  }
  let dt = Math.min(0.06, (now-last)/1000);
  last = now;
  if (!gameOver) update(dt);
  draw(dt);
  requestAnimationFrame(loop);
}

// --- Init ---
function init() {
  console.log('INIT CALLED');
  bestScore = Number(localStorage.getItem('nightdriver_best')) || 0;
  document.getElementById('bestScore').textContent = bestScore;
  restartGame();
  roadScroll = 0;
  requestAnimationFrame(loop);
}
init();

// Ensure all functions and variables are defined before these listeners
window.addEventListener('resize', () => {
  resizeGame();
  updateLaneCenters();
  player.x = laneCenters[1]; // center lane
});
document.addEventListener('DOMContentLoaded', () => {
  resizeGame();
  updateLaneCenters();
  player.x = laneCenters[1]; // center lane
});

  // --- Main Loop ---
  
    // DEBUG: confirm loop is running
    if (window.DEBUG_ONCE_LOOP !== true) {
      console.log('LOOP RUNNING');
      window.DEBUG_ONCE_LOOP = true;
  // Player speed scales with multiplier
  let effectiveSpeed = player.speed * speedMultiplier;
  roadScroll -= effectiveSpeed * 2.6 * dt;
  if (roadScroll < -60) roadScroll += 60; // Make lane dashes scroll UP for forward feel

  // Player movement
  // Smooth left/right movement (classic racer)
  const lateralSpeed = 5;
  if (leftPressed) player.x -= lateralSpeed;
  if (rightPressed) player.x += lateralSpeed;
  // Clamp player to road
  let minX = laneCenters[0] - (laneCenters[1] - laneCenters[0])/2 + player.width/2;
  let maxX = laneCenters[NUM_LANES-1] + (laneCenters[1] - laneCenters[0])/2 - player.width/2;
  player.x = Math.max(minX, Math.min(maxX, player.x));
  // Obstacles
  updateObstacles(dt);
  // Spawn
  obstacleTimer += dt*1000 / speedMultiplier; // spawn rate also speeds up
  if (obstacleTimer > obstacleInterval) {
    obstacleTimer = 0;
    spawnObstacle();
    if (obstacleInterval > minInterval) obstacleInterval -= 3.5 * speedMultiplier; // ramp up faster
  }
  // Collision
  for (let obs of obstacles) {
  if (checkCollision(player, obs)) {
  if (obs.type === 'truck') {
    // Truck collision: game over
    triggerShake(1.7);
    gameOver = true;
    document.getElementById('finalScore').textContent = Math.floor(distance);
    document.getElementById('gameOverScreen').style.display = 'flex';
    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem('nightdriver_best', bestScore);
    }
    document.getElementById('bestScore').textContent = bestScore;
  } else if (obs.type === 'car') {
    // Car collision: penalty, but NOT game over (no shake)
        score = Math.max(0, score - 25);
        obs.x += (Math.random() > 0.5 ? 1 : -1) * 40; // nudge car aside
        obs.y -= 18; // push away
  }
}
  // Near-miss detection (side-by-side, but not colliding)
      else if (!gameOver && Math.abs(player.y-obs.y) < (player.height+obs.height)/2+16 && Math.abs(player.x-obs.x) > (player.width+obs.width)/2 && Math.abs(player.x-obs.x) < (player.width+obs.width)/2+18) {
        // Only trigger once per obstacle
        if (!obs.nearMissed) {
          obs.nearMissed = true;
          score += 10; // bonus points
        }
      }
    }
  }
  // Make obstacles spawn faster as you go
  obstacleInterval = Math.max(minInterval, 700 - distance/2);
}

function draw(dt) {
  if (!window.DEBUG_ONCE_DRAW) { console.log('DRAW RUNNING'); window.DEBUG_ONCE_DRAW = true; }
  // 1. Road, neon background, starfield, etc.
  drawRoad();
  // 2. Headlight cone
  drawHeadlights();
  // 3. Shake effect: only apply to player & obstacles
  let dx = 0;
  if (shake > 0) dx = (Math.random()-0.5)*shake;
  ctx.save();
  ctx.translate(dx, 0);
  drawPlayer();
  for (let obs of obstacles) drawObstacle(obs);
  ctx.restore();
}
</script>
</body>
</html>
