<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Night Driver</title>
  <meta name="description" content="Night Driver: A neon endless racer game. Dodge obstacles, rack up your score, and enjoy retro visuals!">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #101020 60%, #000 100%);
      min-height: 100vh;
      font-family: 'Segoe UI', Arial, sans-serif;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #gameContainer {
      position: relative;
      width: 360px;
      height: 640px;
      max-width: 100vw;
      max-height: 100vh;
      box-shadow: 0 0 32px #0ff8, 0 0 8px #00f4, 0 0 0 #000;
      border-radius: 18px;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 1.3rem;
      letter-spacing: 1px;
      z-index: 2;
      user-select: none;
      text-shadow: 0 0 4px #0ff, 0 0 8px #00f, 0 0 2px #fff;
    }
    #gameOverScreen {
      display: none;
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(10,10,40,0.92);
      color: #fff;
      z-index: 10;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      text-shadow: 0 0 8px #0ff, 0 0 2px #fff;
    }
    #gameOverScreen button {
      margin-top: 24px;
      padding: 12px 32px;
      font-size: 1.2rem;
      border-radius: 8px;
      border: none;
      background: linear-gradient(90deg,#0ff,#08f 80%);
      color: #111;
      font-weight: bold;
      box-shadow: 0 0 8px #0ff;
      cursor: pointer;
    }
    #mobileControls {
      position: absolute;
      bottom: 18px;
      left: 0;
      width: 100%;
      display: flex;
      flex-direction: row;
      justify-content: center;
      gap: 32px;
      z-index: 3;
      pointer-events: none;
    }
    .ctrl-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(0,255,255,0.12);
      border: 2px solid #0ff;
      color: #0ff;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px #0ff8;
      pointer-events: auto;
      user-select: none;
      touch-action: none;
      transition: background 0.2s;
    }
    .ctrl-btn:active {
      background: rgba(0,255,255,0.32);
    }
    @media (max-width: 500px) {
      #gameContainer { width: 98vw; height: 70vw; min-height: 320px; }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="360" height="640"></canvas>
    <div id="hud">
      <span id="score">0</span> m
      <span style="margin-left:16px; font-size:0.9em;">Best: <span id="bestScore">0</span></span>
    </div>
    <div id="gameOverScreen">
      <div style="margin-top: 120px;">Game Over<br><span id="finalScore">0</span> m</div>
      <button id="restartBtn">Restart</button>
    </div>
    <div id="mobileControls">
      <button class="ctrl-btn" id="leftBtn">⟵</button>
      <button class="ctrl-btn" id="rightBtn">⟶</button>
    </div>
  </div>
  <script>
    // --- Game Constants ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;

    // --- Starfield ---
    const stars = Array.from({length: 50}, () => ({
      x: Math.random()*w,
      y: Math.random()*h,
      speed: 0.2 + Math.random()*0.5
    }));
    function drawStars(dt) {
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = '#fff';
      for (let s of stars) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, 1.1+Math.random()*1.2, 0, 2*Math.PI);
        ctx.fill();
        s.y += s.speed * player.speed * dt * 1.2;
        if (s.y > h) s.y = 0, s.x = Math.random()*w;
      }
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }

    // --- Headlight effect ---
    function drawHeadlights() {
      ctx.save();
      ctx.globalAlpha = 0.22;
      const grad = ctx.createRadialGradient(player.x, player.y-20, 16, player.x, player.y-120, 160);
      grad.addColorStop(0, '#fff8');
      grad.addColorStop(0.1, '#0ff6');
      grad.addColorStop(0.4, '#0ff2');
      grad.addColorStop(1, 'transparent');
      ctx.beginPath();
      ctx.ellipse(player.x, player.y-60, 70, 170, 0, 0, 2*Math.PI);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }

    // --- Near-miss shake ---
    let shake = 0, shakeTimer = 0;
    function triggerShake() {
      shake = 12;
      shakeTimer = 0.16;
    }
    function applyShake(dt) {
      if (shake > 0) {
        shakeTimer -= dt;
        if (shakeTimer < 0) shake = 0;
      }
    }

    // --- Game State ---
    let player = { x: w/2, y: h/2, width: 38, height: 64, speed: 9, color: '#0ff' }; // Car in center
    let obstacles = [], obstacleTimer = 0, obstacleInterval = 800, minInterval = 260;
    let distance = 0, score = 0, bestScore = 0;
    let gameOver = false;
    let leftPressed = false, rightPressed = false;
    // --- Controls ---
    function resetControls() { leftPressed = rightPressed = false; }
    document.addEventListener('keydown', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = true;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = true;
      if (gameOver && (e.key===' '||e.key==='Enter')) restartGame();
    });
    document.addEventListener('keyup', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = false;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = false;
    });
    // --- Mobile Touch Controls ---
    document.getElementById('leftBtn').addEventListener('touchstart', e => { leftPressed = true; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('touchend', e => { leftPressed = false; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('mousedown', e => { leftPressed = true; });
    document.getElementById('leftBtn').addEventListener('mouseup', e => { leftPressed = false; });
    document.getElementById('leftBtn').addEventListener('mouseleave', e => { leftPressed = false; });
    document.getElementById('rightBtn').addEventListener('touchstart', e => { rightPressed = true; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('touchend', e => { rightPressed = false; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('mousedown', e => { rightPressed = true; });
    document.getElementById('rightBtn').addEventListener('mouseup', e => { rightPressed = false; });
    document.getElementById('rightBtn').addEventListener('mouseleave', e => { rightPressed = false; });
    // --- Game Functions ---
    function restartGame() {
      player.x = w/2; player.y = h/2; distance = 0; score = 0; obstacles = [];
      gameOver = false; obstacleInterval = 800; resetControls();
      document.getElementById('gameOverScreen').style.display = 'none';
    }
    document.getElementById('restartBtn').onclick = restartGame;
    function drawRoad() {
      ctx.save();
      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, w, h);
      // Shoulders
      ctx.fillStyle = '#0ff2';
      ctx.fillRect(0, 0, w*0.18, h);
      ctx.fillRect(w*0.82, 0, w*0.18, h);
      // Road
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.moveTo(w*0.18, 0);
      ctx.lineTo(w*0.82, 0);
      ctx.lineTo(w*0.7, h);
      ctx.lineTo(w*0.3, h);
      ctx.closePath();
      ctx.fill();
      // Neon lane lines (scrolling)
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 4;
      ctx.setLineDash([28, 24]);
      ctx.lineDashOffset = roadScroll;
      ctx.beginPath();
      ctx.moveTo(w/2, 0);
      ctx.lineTo(w/2, h);
      ctx.stroke();
      ctx.setLineDash([]);
      // Side lines (scrolling)
      ctx.strokeStyle = '#0ff8';
      ctx.lineWidth = 2;
      ctx.setLineDash([16, 18]);
      ctx.lineDashOffset = roadScroll;
      ctx.beginPath();
      ctx.moveTo(w*0.24, 0);
      ctx.lineTo(w*0.24, h);
      ctx.moveTo(w*0.76, 0);
      ctx.lineTo(w*0.76, h);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
    function drawPlayer() {
      ctx.save();
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 18;
      // Neon car body
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(player.x, player.y-player.height/2); // nose
      ctx.lineTo(player.x+player.width/2-6, player.y-player.height/2+20); // right hood
      ctx.lineTo(player.x+player.width/2, player.y+player.height/2-10); // right rear
      ctx.lineTo(player.x-player.width/2, player.y+player.height/2-10); // left rear
      ctx.lineTo(player.x-player.width/2+6, player.y-player.height/2+20); // left hood
      ctx.closePath();
      ctx.fill();
      // Windows
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = '#fff';
      ctx.fillRect(player.x-10, player.y-18, 20, 20);
      ctx.globalAlpha = 1.0;
      // Wheels
      ctx.fillStyle = '#222';
      ctx.fillRect(player.x-18, player.y-26, 8, 22);
      ctx.fillRect(player.x+10, player.y-26, 8, 22);
      ctx.fillRect(player.x-18, player.y+4, 8, 22);
      ctx.fillRect(player.x+10, player.y+4, 8, 22);
      ctx.restore();
    }
    function drawObstacle(obs) {
      ctx.save();
      ctx.shadowColor = obs.color;
      ctx.shadowBlur = 12;
      if (obs.type === 'truck') {
        // Neon truck: cab + trailer
        ctx.fillStyle = obs.color;
        ctx.fillRect(obs.x-obs.width/2, obs.y-obs.height/2, obs.width, obs.height*0.65); // trailer
        ctx.fillStyle = '#fff';
        ctx.fillRect(obs.x-obs.width/2, obs.y-obs.height/2+obs.height*0.65, obs.width, obs.height*0.35); // cab
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2;
        ctx.strokeRect(obs.x-obs.width/2, obs.y-obs.height/2, obs.width, obs.height);
        // Wheels
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(obs.x-obs.width/3, obs.y+obs.height/2-6, 6, 0, 2*Math.PI);
        ctx.arc(obs.x+obs.width/3, obs.y+obs.height/2-6, 6, 0, 2*Math.PI);
        ctx.fill();
      } else {
        // Neon car obstacle
        ctx.fillStyle = obs.color;
        ctx.beginPath();
        ctx.moveTo(obs.x, obs.y-obs.height/2); // nose
        ctx.lineTo(obs.x+obs.width/2-4, obs.y-obs.height/2+14); // right hood
        ctx.lineTo(obs.x+obs.width/2, obs.y+obs.height/2-8); // right rear
        ctx.lineTo(obs.x-obs.width/2, obs.y+obs.height/2-8); // left rear
        ctx.lineTo(obs.x-obs.width/2+4, obs.y-obs.height/2+14); // left hood
        ctx.closePath();
        ctx.fill();
        // Windows
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#fff';
        ctx.fillRect(obs.x-8, obs.y-obs.height/2+8, 16, 14);
        ctx.globalAlpha = 1.0;
        // Wheels
        ctx.fillStyle = '#222';
        ctx.fillRect(obs.x-obs.width/2+2, obs.y-obs.height/2+4, 6, 12);
        ctx.fillRect(obs.x+obs.width/2-8, obs.y-obs.height/2+4, 6, 12);
        ctx.fillRect(obs.x-obs.width/2+2, obs.y+obs.height/2-16, 6, 12);
        ctx.fillRect(obs.x+obs.width/2-8, obs.y+obs.height/2-16, 6, 12);
      }
      ctx.restore();
    }
    function updateObstacles(dt) {
      for (let obs of obstacles) obs.y += obs.speed * dt;
      obstacles = obstacles.filter(obs => obs.y - obs.height/2 < h);
    }
    function spawnObstacle() {
  // Always leave at least one open lane
  const lanes = [0, 1, 2];
  // Decide how many lanes to block (1 or 2, never 3)
  let blockCount = Math.random() < 0.7 ? 1 : 2;
  let blocked = [];
  while (blocked.length < blockCount) {
    let l = lanes[Math.floor(Math.random()*lanes.length)];
    if (!blocked.includes(l)) blocked.push(l);
  }
  // Prevent overlapping: only spawn if no other obstacle is close in the lane
  for (let lane of blocked) {
    const laneX = w*0.3 + lane*w*0.2;
    // Find the closest obstacle in this lane
    let tooClose = obstacles.some(o => Math.abs(o.x - laneX) < 10 && o.y < 120);
    if (tooClose) continue;
    // 60% truck, 40% car
    if (Math.random() < 0.6) {
      obstacles.push({
        x: laneX, y: -60, width: 38, height: 88+Math.random()*18,
        speed: 8.5 + Math.random()*2.5 + distance/150, // much faster trucks
        color: '#ff0', type: 'truck'
      });
    } else {
      obstacles.push({
        x: laneX, y: -40, width: 36, height: 44+Math.random()*10,
        speed: 7.2 + Math.random()*2.5 + distance/200,
        color: ['#f33','#0ff','#0f0'][Math.floor(Math.random()*3)], type: 'car'
      });
    }
  }
}
    function checkCollision(a, b) {
      return Math.abs(a.x-b.x) < (a.width+b.width)/2 && Math.abs(a.y-b.y) < (a.height+b.height)/2;
    }
    function update(dt) {
  applyShake(dt); // update shake

  roadScroll += player.speed * 2.6 * dt;
  if (roadScroll > 52) roadScroll -= 52; // 28+24 from lane dash
      // Player movement
      if (leftPressed) player.x -= player.speed;
      if (rightPressed) player.x += player.speed;
      // Clamp to road
      player.x = Math.max(w*0.21 + player.width/2, Math.min(w*0.79 - player.width/2, player.x));
      // Obstacles
      updateObstacles(dt);
      // Spawn
      obstacleTimer += dt*1000;
      if (obstacleTimer > obstacleInterval) {
        obstacleTimer = 0;
        spawnObstacle();
        if (obstacleInterval > minInterval) obstacleInterval -= 2;
      }
      // Collision
      for (let obs of obstacles) {
        if (checkCollision(player, obs)) {
          gameOver = true;
          document.getElementById('finalScore').textContent = Math.floor(distance);
          document.getElementById('gameOverScreen').style.display = 'flex';
          if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('nightdriver_best', bestScore);
          }
          document.getElementById('bestScore').textContent = bestScore;
        }
        // Near-miss detection (side-by-side, but not colliding)
        else if (!gameOver && Math.abs(player.y-obs.y) < (player.height+obs.height)/2+16 && Math.abs(player.x-obs.x) > (player.width+obs.width)/2 && Math.abs(player.x-obs.x) < (player.width+obs.width)/2+18) {
          // Only trigger once per obstacle
          if (!obs.nearMissed) {
            obs.nearMissed = true;
            triggerShake();
            score += 10; // bonus points
          }
        }
      }
      // Score
      if (!gameOver) {
        // Increase speed as you go further
  player.speed = 10.5 + Math.min(18, distance/110);
  distance += dt*player.speed*2.25;
  score = Math.floor(distance);
  document.getElementById('score').textContent = score;
  // Make obstacles spawn faster as you go
  obstacleInterval = Math.max(minInterval, 700 - distance/2);
      }
    }
    function drawStars(dt) {
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < 100; i++) {
        ctx.fillRect(Math.random()*w, Math.random()*h, 2, 2);
      }
      ctx.globalAlpha = 1.0;
    }
    function drawHeadlights() {
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(player.x, player.y-player.height/2);
      ctx.lineTo(player.x+player.width/2, player.y-player.height/2+20);
      ctx.lineTo(player.x+player.width/2+20, player.y-player.height/2+40);
      ctx.lineTo(player.x, player.y-player.height/2+40);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1.0;
    }
    function draw(dt) {
      drawStars(dt);
      drawRoad();
      drawHeadlights();
      let dx = 0;
      if (shake > 0) dx = (Math.random()-0.5)*shake;
      ctx.save();
      ctx.translate(dx, 0);
      drawPlayer();
      for (let obs of obstacles) drawObstacle(obs);
      ctx.restore();
    }
    // --- Main Loop ---
    let last = performance.now();
    function loop(now) {
      let dt = Math.min(0.06, (now-last)/1000);
      last = now;
      if (!gameOver) update(dt);
      draw(dt);
      requestAnimationFrame(loop);
    }
    // --- Init ---
    function init() {
      bestScore = Number(localStorage.getItem('nightdriver_best')) || 0;
      document.getElementById('bestScore').textContent = bestScore;
      restartGame();
      loop(performance.now());
    }
    init();
  </script>
</body>
</html>
