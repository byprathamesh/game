<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Night Driver</title>
  <meta name="description" content="Night Driver: A neon endless racer game. Dodge obstacles, rack up your score, and enjoy retro visuals!">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    body {
      font-family: 'Press Start 2P', 'VT323', 'Consolas', monospace;
      background: #181818;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #181818;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      border: none;
    }
    #hud, #gameOverScreen {
      font-family: 'Press Start 2P', 'VT323', 'Consolas', monospace;
      text-shadow: none;
      color: #fff;
    }
    .game-btn, #muteBtn {
      font-family: 'Press Start 2P', 'VT323', 'Consolas', monospace;
      border-radius: 0;
      background: #222;
      color: #fff;
      border: 2px solid #888;
    }
  </style>
  <script>
    // Responsive resize logic to maintain 360x640 aspect ratio
    function resizeGame() {
      const aspect = 360 / 640;
      let w = window.innerWidth;
      let h = window.innerHeight;
      if (w / h > aspect) {
        w = h * aspect;
      } else {
        h = w / aspect;
      }
      const container = document.getElementById('gameContainer');
      container.style.width = w + 'px';
      container.style.height = h + 'px';
      const canvas = container.querySelector('canvas');
      if (canvas) {
        canvas.width = 320;
        canvas.height = 480;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
      }
    }
  </script>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="320" height="480" style="width: 100vw; height: 100vh; image-rendering: pixelated; image-rendering: crisp-edges; background: #181818; display: block; margin: 0 auto;"></canvas>
    <div id="hud">
      <span id="score">0</span> m
      <span style="margin-left:16px; font-size:0.9em;">Best: <span id="bestScore">0</span></span>
    </div>
    <div id="gameOverScreen">
      <div style="margin-top: 120px;">Game Over<br><span id="finalScore">0</span> m</div>
      <button id="restartBtn">Restart</button>
    </div>
    <div id="mobileControls">
      <button class="ctrl-btn" id="leftBtn">⟵</button>
      <button class="ctrl-btn" id="rightBtn">⟶</button>
    </div>
  </div>
  <script>
    // --- Game Constants ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    let roadScroll = 0;

    // --- Starfield ---
    function drawStarfield() {
      for (let i = 0; i < 48; i++) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(Math.floor(Math.random()*320), Math.floor(Math.random()*480), 2, 2);
      }
    }

    // --- Headlight effect ---
    function drawHeadlights() {
      ctx.save();
      ctx.globalAlpha = 0.22;
      const grad = ctx.createRadialGradient(player.x, player.y-20, 16, player.x, player.y-120, 160);
      grad.addColorStop(0, '#fff8');
      grad.addColorStop(0.1, '#0ff6');
      grad.addColorStop(0.4, '#0ff2');
      grad.addColorStop(1, 'transparent');
      ctx.beginPath();
      ctx.ellipse(player.x, player.y-60, 70, 170, 0, 0, 2*Math.PI);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }

    // --- Near-miss shake ---
    let shake = 0, shakeTimer = 0;
    function triggerShake(intensity=1) {
      shake = 18 * intensity;
      shakeTimer = 0.22 * intensity;
    }
    function applyShake(dt) {
      if (shake > 0) {
        shakeTimer -= dt;
        if (shakeTimer < 0) shake = 0;
      }
    }

    // --- Game State ---
    const NUM_LANES = 3;
    let laneCenters = [];
    function updateLaneCenters() {
      laneCenters = [];
      // Road from w * 0.18 to w * 0.82 for more space, evenly spaced for 3 lanes
      let roadLeft = w * 0.18;
      let roadRight = w * 0.82;
      let laneWidth = (roadRight - roadLeft) / 3;
      for (let i = 0; i < 3; i++) {
        laneCenters.push(roadLeft + laneWidth/2 + i * laneWidth);
      }
    }
    updateLaneCenters();
    let player = { x: laneCenters[1], y: h/2, width: 38, height: 64, speed: 15, color: '#0ff' }; // Start in center lane
    let obstacles = [], obstacleTimer = 0, obstacleInterval = 540, minInterval = 90;
    let distance = 0, score = 0, bestScore = 0;
    let speedMultiplier = 1;
    let gameOver = false;
    let leftPressed = false, rightPressed = false;
    // --- Controls ---
    function resetControls() { leftPressed = rightPressed = false; }
    document.addEventListener('keydown', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = true;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = true;
      if (gameOver && (e.key===' '||e.key==='Enter')) restartGame();
    });
    document.addEventListener('keyup', e => {
      if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') leftPressed = false;
      if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') rightPressed = false;
    });
    // --- Mobile Touch Controls ---
    document.getElementById('leftBtn').addEventListener('touchstart', e => { leftPressed = true; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('touchend', e => { leftPressed = false; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('mousedown', e => { leftPressed = true; });
    document.getElementById('leftBtn').addEventListener('mouseup', e => { leftPressed = false; });
    document.getElementById('leftBtn').addEventListener('mouseleave', e => { leftPressed = false; });
    document.getElementById('rightBtn').addEventListener('touchstart', e => { rightPressed = true; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('touchend', e => { rightPressed = false; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('mousedown', e => { rightPressed = true; });
    document.getElementById('rightBtn').addEventListener('mouseup', e => { rightPressed = false; });
    document.getElementById('rightBtn').addEventListener('mouseleave', e => { rightPressed = false; });
    // --- Game Functions ---
    function restartGame() {
      player.x = w/2; player.y = h/2; distance = 0; score = 0; obstacles = [];
      gameOver = false; obstacleInterval = 540; resetControls();
      document.getElementById('gameOverScreen').style.display = 'none';
    }
    document.getElementById('restartBtn').onclick = restartGame;
    // (removed duplicate declaration and code, only one starfield system remains)

    function drawRoad() {
      ctx.save();
      // Neon gradient background
      let grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, '#0ff8');
      grad.addColorStop(0.5, '#181e3c');
      grad.addColorStop(1, '#000');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
      // Animated starfield
      drawStarfield();
      // Glowing road
      ctx.save();
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 36;
      ctx.fillStyle = '#222';
      ctx.fillRect(w*0.21, 0, w*0.58, h);
      ctx.restore();
      // Animated road texture
      let scrollOffset = roadScroll % 32;
      for (let i = -32; i < h; i += 32) {
        ctx.fillStyle = i % 64 === 0 ? '#181818' : '#191919';
        ctx.fillRect(w*0.21, i + scrollOffset, w*0.58, 16);
      }
      // Pixelated lane markings (2 solid lines for 3 lanes)
      ctx.save();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 4;
      ctx.setLineDash([14, 10]); // shorter dashes for pixel look
      let roadLeft = Math.round(w * 0.18);
      let roadRight = Math.round(w * 0.82);
      let laneWidth = Math.round((roadRight - roadLeft) / 3);
      for (let i = 1; i < 3; i++) {
        let x = Math.round(roadLeft + i * laneWidth);
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      ctx.restore();
      // Road edge lines
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 7;
      ctx.beginPath();
      ctx.moveTo(w*0.21, 0);
      ctx.lineTo(w*0.21, h);
      ctx.moveTo(w*0.79, 0);
      ctx.lineTo(w*0.79, h);
      ctx.moveTo(w/2, 0);
      ctx.lineTo(w/2, h);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(Math.round(player.x), Math.round(player.y));
      // Pixel car body
      ctx.fillStyle = player.color;
      ctx.fillRect(-16, -28, 32, 56);
      // Pixel windows
      ctx.fillStyle = '#7ec7ff';
      ctx.fillRect(-10, -20, 20, 12);
      // Pixel headlights
      ctx.fillStyle = '#fff';
      ctx.fillRect(-8, 24, 6, 8);
      ctx.fillRect(2, 24, 6, 8);
      // Pixel wheels
      ctx.fillStyle = '#222';
      ctx.fillRect(-14, -24, 4, 8);
      ctx.fillRect(10, -24, 4, 8);
      ctx.fillRect(-14, 16, 4, 8);
      ctx.fillRect(10, 16, 4, 8);
      ctx.restore();
    }

    function drawObstacle(obs) {
  ctx.save();
  ctx.translate(Math.round(obs.x), Math.round(obs.y));
  if (obs.type === 'truck') {
    // Pixel truck: big rectangle, pixel headlights
    ctx.fillStyle = obs.color;
    ctx.fillRect(-16, -40, 32, 80);
    ctx.fillStyle = '#fff';
    ctx.fillRect(-10, -40, 8, 8);
    ctx.fillRect(2, -40, 8, 8);
    ctx.fillStyle = '#222';
    ctx.fillRect(-14, 28, 6, 10);
    ctx.fillRect(8, 28, 6, 10);
  } else {
    // Pixel car: small rectangle, pixel headlights
    ctx.fillStyle = obs.color;
    ctx.fillRect(-8, -14, 16, 28);
    ctx.fillStyle = '#fff';
    ctx.fillRect(-6, -14, 5, 6);
    ctx.fillRect(1, -14, 5, 6);
    ctx.fillStyle = '#222';
    ctx.fillRect(-8, 6, 4, 6);
    ctx.fillRect(4, 6, 4, 6);
  }
  ctx.restore();
}
    function updateObstacles(dt) {
  for (let obs of obstacles) obs.y += obs.speed * dt * speedMultiplier;
  obstacles = obstacles.filter(obs => obs.y - obs.height/2 < h);
}
    function spawnObstacle() {
  // Always leave at least one open lane, and only one obstacle per lane
  const lanes = [0, 1, 2];
  // Randomly pick one lane to remain open
  let openLane = lanes[Math.floor(Math.random() * lanes.length)];
  const spawnY = -80;
  let spawned = 0;
  for (let lane = 0; lane < 3; lane++) {
    if (lane === openLane) continue;
    const laneX = laneCenters[lane];
    // Only spawn if no obstacle is already in this lane and visible
    let laneBlocked = obstacles.some(o => o.lane === lane && o.y < h && o.y > -120);
    if (laneBlocked) continue;
    // Prevent spawning more than two obstacles (one per non-open lane)
    if (spawned >= 2) break;
    if (Math.random() < 0.6) {
      obstacles.push({
        x: laneX, y: spawnY, width: 36, height: 88 + Math.random() * 12,
        speed: (16 + Math.random() * 4 + distance / 60) * speedMultiplier,
        color: '#ff0', type: 'truck', lane: lane
      });
    } else {
      obstacles.push({
        x: laneX, y: spawnY, width: 16, height: 32 + Math.random() * 6,
        speed: (14 + Math.random() * 4 + distance / 90) * speedMultiplier,
        color: ['#f33', '#0ff', '#0f0'][Math.floor(Math.random() * 3)], type: 'car', lane: lane
      });
    }
    spawned++;
  }
}

function checkCollision(a, b) {
  return Math.abs(a.x-b.x) < (a.width+b.width)/2 && Math.abs(a.y-b.y) < (a.height+b.height)/2;
}

function update(dt) {
  if (!window.DEBUG_ONCE_UPDATE) { console.log('UPDATE RUNNING'); window.DEBUG_ONCE_UPDATE = true; }
  applyShake(dt); // update shake
  speedMultiplier = 1 + distance / 900;
  let effectiveSpeed = player.speed * speedMultiplier;
  roadScroll -= effectiveSpeed * 2.6 * dt;
  if (roadScroll < -60) roadScroll += 60;
  const lateralSpeed = 5;
  if (leftPressed) player.x -= lateralSpeed;
  if (rightPressed) player.x += lateralSpeed;
  let minX = laneCenters[0] - (laneCenters[1] - laneCenters[0])/2 + player.width/2;
  let maxX = laneCenters[NUM_LANES-1] + (laneCenters[1] - laneCenters[0])/2 - player.width/2;
  player.x = Math.max(minX, Math.min(maxX, player.x));
  updateObstacles(dt);
  obstacleTimer += dt*1000 / speedMultiplier;
  if (obstacleTimer > obstacleInterval) {
    obstacleTimer = 0;
    spawnObstacle();
    if (obstacleInterval > minInterval) obstacleInterval -= 3.5 * speedMultiplier;
  }
  for (let obs of obstacles) {
    if (checkCollision(player, obs)) {
      if (obs.type === 'truck') {
        triggerShake(1.7);
        gameOver = true;
        document.getElementById('finalScore').textContent = Math.floor(distance);
        document.getElementById('gameOverScreen').style.display = 'flex';
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem('nightdriver_best', bestScore);
        }
        document.getElementById('bestScore').textContent = bestScore;
      } else if (obs.type === 'car') {
        score = Math.max(0, score - 25);
        obs.x += (Math.random() > 0.5 ? 1 : -1) * 40;
        obs.y -= 18;
      }
    } else if (!gameOver && Math.abs(player.y-obs.y) < (player.height+obs.height)/2+16 && Math.abs(player.x-obs.x) > (player.width+obs.width)/2 && Math.abs(player.x-obs.x) < (player.width+obs.width)/2+18) {
      if (!obs.nearMissed) {
        obs.nearMissed = true;
        score += 10;
      }
    }
  }
  obstacleInterval = Math.max(minInterval, 700 - distance/2);
}

function draw(dt) {
  if (!window.DEBUG_ONCE_DRAW) { console.log('DRAW RUNNING'); window.DEBUG_ONCE_DRAW = true; }
  drawRoad();
  drawHeadlights();
  let dx = 0;
  if (shake > 0) dx = (Math.random()-0.5)*shake;
  ctx.save();
  ctx.translate(dx, 0);
  drawPlayer();
  for (let obs of obstacles) drawObstacle(obs);
  ctx.restore();
}

// --- Main Loop ---
let last = performance.now(); // Only ONE declaration allowed, before loop()
function loop(now) {
  if (window.DEBUG_ONCE_LOOP !== true) {
    console.log('LOOP RUNNING');
    window.DEBUG_ONCE_LOOP = true;
  }
  let dt = Math.min(0.06, (now-last)/1000);
  last = now;
  if (!gameOver) update(dt);
  draw(dt);
  requestAnimationFrame(loop);
}

// --- Init ---
function init() {
  console.log('INIT CALLED');
  try {
  bestScore = Number(localStorage.getItem('nightdriver_best')) || 0;
} catch (e) {
  bestScore = 0;
}
  document.getElementById('bestScore').textContent = bestScore;
  restartGame();
  roadScroll = 0;
  requestAnimationFrame(loop);
}
init();

// Ensure all functions and variables are defined before these listeners
window.addEventListener('resize', () => {
  resizeGame();
  updateLaneCenters();
  player.x = laneCenters[1]; // center lane
});
document.addEventListener('DOMContentLoaded', () => {
  resizeGame();
  updateLaneCenters();
  player.x = laneCenters[1]; // center lane
});

// --- END OF GAME SCRIPT ---
</script>
</body>
</html>
    document.getElementById('bestScore').textContent = bestScore;
  } else if (obs.type === 'car') {
    // Car collision: penalty, but NOT game over (no shake)
        score = Math.max(0, score - 25);
        obs.x += (Math.random() > 0.5 ? 1 : -1) * 40; // nudge car aside
        obs.y -= 18; // push away
  }
}
  // Near-miss detection (side-by-side, but not colliding)
      else if (!gameOver && Math.abs(player.y-obs.y) < (player.height+obs.height)/2+16 && Math.abs(player.x-obs.x) > (player.width+obs.width)/2 && Math.abs(player.x-obs.x) < (player.width+obs.width)/2+18) {
        // Only trigger once per obstacle
        if (!obs.nearMissed) {
          obs.nearMissed = true;
          score += 10; // bonus points
        }
      }
    }
  }
  // Make obstacles spawn faster as you go
  obstacleInterval = Math.max(minInterval, 700 - distance/2);
}

function draw(dt) {
  if (!window.DEBUG_ONCE_DRAW) { console.log('DRAW RUNNING'); window.DEBUG_ONCE_DRAW = true; }
  // 1. Road, neon background, starfield, etc.
  drawRoad();
  // 2. Headlight cone
  drawHeadlights();
  // 3. Shake effect: only apply to player & obstacles
  let dx = 0;
  if (shake > 0) dx = (Math.random()-0.5)*shake;
  ctx.save();
  ctx.translate(dx, 0);
  drawPlayer();
  for (let obs of obstacles) drawObstacle(obs);
  ctx.restore();
}
// --- END OF GAME SCRIPT ---
</script>
</body>
</html>
